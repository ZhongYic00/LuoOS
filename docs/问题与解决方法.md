# 问题与解决方案（决赛部分）

- 随着功能需求与项目规模的增长，我们也在开发中边学习边实践地引入了优秀的软件工程方法。主要有如下几点：  
	- 更好的版本控制，由于内核开发中难点众多，预先设想的roadmap往往在实现时遇到阻碍，因此我们采用了更为复杂的多分支开发方式。如在实现新系统调用的同时，另一位同学在重构文件系统、内存系统，此时发现调用层传参的bug则会通过bug-fix分支同时合入两边的开发主线；如在最终对busybox和musl-libc的适配中，某一测例上难以定位bug，则会优先推进另一测例；如信号模块的完整功能实现过程较长，我们会保留开发分支，逐步演进集成。  
	- 更好的编码规范，我们能够通过doxygen风格的`@todo @bug @note`等注释进行更好的交流交接，通过commit message快速定位bug或是feature来源，通过防御性编程更好的发现问题。我们也正在优化项目的代码结构，将部分过长的单一模块拆分至多个子模块，将过长的头文件移动至源码文件中。  

- 主要是前两天晚上看到的结构化绑定`auto [x,y,z]=tuple1;`  
    - 然后就发现EASTL里挺多地方依赖了STL。。。比如这里就被狠狠地坑了，它内部实现是自己declare了一套`tuple_size/tuple_element`的模板，结果最下面结合std的部分，是直接引用的`<tuple>`。然后因为我这没法引STL我给注释了，就缺少了模板类的declare。。。  
        - 报错信息也不干人事，`xxx is not a template`  

- 解决了这个问题之后又报错`undefined reference to __atomic_compare_exchange_1/2`😇  
	- 折腾一圈，先是手动`-latomic`，然而并没有什么效果（甚至我忘了不加这个fetchadd也是正常的）  
	- 然后反汇编了一下`libatomic.a`  
		- 本以为是没使用原子指令，其实有`lr.d/sc.d`，当然占比比想象的少很多  
		- 最后发现真没那函数。。哦，原来是数据宽度的问题，指令只支持4或者8。。  

- 今天改造一下BCache #[[OS Impl]]  
	- 非常头疼的是，LRU不会管当前的块是否被占用，就得从外部封一层，然后就碰到一致性问题了  
		- 基本思想是实现为buffer释放时扔进LRU？  
		- 或者创建时扔进LRU，那么可能出现刷出去之后实际还在被占用，此时别的进程又读写这个块那就有两个buffer了，就有一致性问题  
	- 目前实现了一版很糟糕的  
	- 另一种思路  
		- 申请内存时就记录在全局表里，然后给sharedptr管理，删除的时候扔进lru  
		- 也就是实现一个特殊的allocator  
			- 。。。sharedptr不支持指定allocator  
    - 最麻烦的点在于，LRU通常是one-shot的（如值拷贝），但这里却是transactional的  
        - 目前的实现其实不好，正常来说每次access都该对lru产生影响，然后很久没access之后就清理了；考虑ref的影响则是引用全释放之后、若不在lru里就清理掉  
        - 由于ref的存在，为了一致性必须在ref销毁前保留索引  
        - 思路：list还是lru并持有ref，map只保留weakref  
    - 还有俩问题，不过得后面再整了  
        - Linux的buffer似乎是变长的  
        - 如何处理page cache和buffer cache的关系  

- 牛逼的bug，真是出人意料：  
  必须得在docker里编译，然后运行的时候`memInit`末尾的log会死在`vsnprintf`，表现为一个字符串地址读不了  
	- 有个段叫srodata，之前一直给忽略了  
	- 之前实际上srodta藏在rodata页的末尾，碰巧字符串多了之后，docker里的编译结果可能会srodata变长超出rodata页  
	- 改了下链接脚本，把其他的srodata都扔rodata里了

- 刚才某个版本的编译结果能在QEMU 5上跑通，但不能在7.0上跑通，结果调了下调试信息就都跑不通了。。。  
	- 一番玄学调整后，死在了copyout上  
		- 目前是改成了把当前vmo映射到内核空间，但可能存在跨vmo的  
	- 然后5.0能跑通了，7.0还是不行，clone测例会死循环  
		- 表现为，ctx存着kctx的内容。。。  
		- 吐辣，又是遗留bug。。`_strapexit`里之前留了个地方记录`ctx.pc<0x100000`的情况，结果是在切页表中间，新版本估计检测更严格写就expection了  
		- 现在还有这么个潜在问题，切页表之后和当前特权级之间可能有不一致性，加个assertion吧  

- 试了下内核开O1都不行，很容易就寄了
	- 一番debug发现tp被改写了？似乎不保证不使用tp，所以可能得专门用sscratch之类的存hartid或者khartobj指针

- 似乎还有个问题，释放之后又拿到原来的blockbuf进行写入  
	- 。。。就是这里的问题，傻X了  
	- C++太难整了，千万记得该`=delete`的构造函数得声明、该引用的得引用，不能随便把指针解引用  

- 目前`busybox --help`会死在`close_file`的`__lockfile`里，`busybox sh --help`会死在`xfunc_die`里（疑似因为没跑`init_main`而没有初始化？可以再看下是不是在bss段而没清零）  
	- 调啊调，mmap啥的太tm难了。这里又是因为装载elf的时候，filesz部分是装进内存的，余下的应当赋0，而且这个长度也不是对齐的  
	- 调试入口  
	  ```
	  	  b ld.cc:43
	  	  c
	  	  display /a entry
	  	  display /a entry.p_vaddr+entry.p_memsz
	  	  c
	  	  b SwapPager::load
	  ```

又寄在segment上了捏😋munmap那里改的时候没注意是`[base,base+len-1]`

- 管道，虽然remake了一版但还是弄错了个地方，读的时候会发生什么？  
	- 如果管道中没有数据，并且没有其他进程打开了写入端，那么read()会返回0，表示已经到达文件末尾。  
	- 如果管道中没有数据，并且有其他进程打开了写入端，并且没有设置非阻塞标志，那么read()会阻塞，直到有数据可读或者写入端被关闭。  
	- 如果管道中没有数据，并且有其他进程打开了写入端，并且设置了非阻塞标志，那么read()会返回-1，并且设置errno为EAGAIN或者EWOULDBLOCK，表示暂时没有数据可读。  
	- 如果管道中有数据，并且要读取的字节数（count）大于或等于管道中的字节数，那么read()会返回实际读取到的字节数，并且清空管道。  
	- 如果管道中有数据，并且要读取的字节数（count）小于管道中的字节数，那么read()会返回要读取的字节数（count），并且保留剩余的数据在管道中。  

- 又单独编译了一下lua，本来是加dbgsym的，结果跑通了。。。  
  后来把-g去掉再跑，还是通了。。。  
  甚至musl查不到挂掉的elf里的好多符号，严重怀疑不是musl编译出来的  
- libc-test好多能混过去，实际没实现  
	- 其中有个地方挂在用户栈空间上，调成8 pages又好了。。为什么不是通过rlimit之类的调整呢  
	- 实现了futex，靠后的几个test都过了，唯独一开始的几个pthread测试过不了  

- 好耶，musl的`libc.so`总算能直接调C了  
	- 调试脚本，主要是自己编译的musl，以及动态链接库要给定`.text`起址  
	  ```
	  	  b panic
	  	  b reboot
	  	  b ld.cc:53
	  	  c
	  	  set enableLevel=1
	  	  set kLogger.outputLevel=1
	  	  b trap.cc:222
	  	  c 
	  	  delete breakpoints
	  	  add-symbol-file obj/testsuit/sdcard/entry-dynamic.exe
	  	  add-symbol-file /mnt/rootb/libc.so 0x70014250
	  	  directory obj/testsuit/libc-test/src
	  	  directory obj/testsuit/musl/riscv-musl
	  ```
	- 给`0x5ebc0(__libc_start_main@got.plt)`打了watch point，结果突然没触发就变成0了  
	- 原来是mprotect挂了。。。  
		- 还两个问题，一个是`base+len-1`，一个是`splitChild`之后的offset没偏移  
	- 然后mmap也挂了  
		-  
		  > #[[new bing]]  
		  根据我的搜索结果，如果你用mmap系统调用映射了一个大小为8KB的文件到内存里，但是映射区域长度为12KB，那么对超出部分的读写会有以下的行为：  
		    
		  - 如果你使用**MAP_PRIVATE**标志，那么超出部分的读取会返回**零**，写入会导致**拷贝写**分配，但是不会影响文件本身¹²。  
		  - 如果你使用**MAP_SHARED**标志，那么超出部分的读取会返回**零**，写入会导致文件被**扩展**并且反映到磁盘上²³。这种情况下，你必须用**O_RDWR**打开文件，并且用**PROT_WRITE**保护映射区域²。  
		    
		  希望这能帮到你。👍  
		    
		  Source: Conversation with Bing, 2023/7/31  
		  (1) why we can mmap to a file but exceed the file size?. https://stackoverflow.com/questions/47604431/why-we-can-mmap-to-a-file-but-exceed-the-file-size.  
		  (2) c - Mmap() an entire large file - Stack Overflow. https://stackoverflow.com/questions/7222164/mmap-an-entire-large-file.  
		  (3) What is the behaviour of a file-backed memory map when reading from or .... https://unix.stackexchange.com/questions/616848/what-is-the-behaviour-of-a-file-backed-memory-map-when-reading-from-or-writing-t.  
		  (4) mmap - How big can a memory-mapped file be? - Stack Overflow. https://stackoverflow.com/questions/726471/how-big-can-a-memory-mapped-file-be.  