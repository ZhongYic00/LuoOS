# 进程管理
支持了虚拟内存后，我们就可以实现用户进程了。从执行流的视角，用户进程的运行实际上是一个事件循环中的一部分：`内核初始化->( 时钟中断 -> 选择下一个执行的进程 -> 回退进用户模式执行用户进程 )`，而调度器则主要是用于获取下一个执行的进程，依赖很少非常模块化。  
本章同样只做关键部分的介绍，分别从进程线程、进程调度进行。  
## 进程线程  
进程线程分离的设计是采用了OpenHarmony、Zircon等新近设计系统的结构，这样能更好的体现出进程和线程的资源管理与运行环境功能划分，我们分别定义了 `Process` 与 `Task`类作为控制块。  

线程中封装有用户态上下文`Context ctx`和内核态上下文`kctx`，其中`kctx`额外存有当前线程的内核栈位置（内核空间地址）等。线程中还存有当前线程目前所处的特权级 `lastpriv` ，以供任务切换时进入正确的特权级。进程中封装有当前进程的地址空间管理对象`vmar`、文件打开表 `files` 和当前进程的子线程 `tasks` 等。

用户进程的创建我们采用从ELF文件创建的方式，根据ELF标准定义简单实现了一个装载函数`loadElf()`在`ld.cc`中，其会从指定的内存区域按照ELF格式读取信息，然后将需要载入内存的段按照该段的读、写、执行权限在给定的进程中创建页表映射，并将ELF文件中该段的内容拷贝过去。由于此时还没有文件系统，我们是将用户程序的ELF文件以二进制格式直接链接进了内核程序的data段，然后在链接脚本中给出相应的内存地址供`loadElf`读取。  

在内核初始化时，我们调用`createProcess()`方法手工创建了第一个用户进程，并将其的默认（进程创建时自动创建一个）线程加入了调度器。
``` c++
auto uproc=proc::createProcess();	//创建进程对象（同时创建了默认线程）
uproc->defaultTask()->ctx.pc=	//将pc设为ELF里读到的Entry地址
  	ld::loadElf((uint8_t*)((xlen_t)&_uimg_start),uproc->vmar);
kGlobObjs.scheduler.add(uproc->defaultTask());
```
## 进程调度  
目前采用了较为简单的实现，即多优先级时间片轮转。当然为了未来扩展进程线程两级调度，我们抽象出了调度信息单元 `Schedulable`包含状态和优先级，进程线程类都继承自该类。调度器内部目前具有`ready`和`pending`两个循环链表，分别存放就绪/正在执行的和阻塞态的线程。